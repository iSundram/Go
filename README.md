# Go Decompiler

A Go decompiler that analyzes compiled Go binaries and attempts to reconstruct the original Go source code with high accuracy.

## Features

- **Multi-platform Support**: Supports ELF (Linux), PE (Windows), and Mach-O (macOS) binary formats
- **Symbol Analysis**: Extracts and analyzes symbols from compiled binaries
- **Function Reconstruction**: Identifies and reconstructs user-defined functions
- **String Literal Recovery**: Extracts string literals from the binary
- **Package Detection**: Automatically detects package names and imports
- **Smart Filtering**: Filters out runtime and standard library functions to focus on user code
- **Comprehensive Testing**: Includes unit tests and integration tests

## Installation

```bash
git clone https://github.com/iSundram/Go.git
cd Go
go build -o go-decompiler main.go
```

## Usage

### Basic Usage

```bash
./go-decompiler <binary-file>
```

### Examples

```bash
# Decompile a simple program
./go-decompiler samples/hello

# Decompile a program with multiple functions  
./go-decompiler samples/functions

# Decompile a complex program
./go-decompiler samples/complex
```

### For Best Results

To get the most accurate decompilation results, compile your Go programs without optimization:

```bash
go build -gcflags="-N -l" -o program program.go
./go-decompiler program
```

The `-N` flag disables optimizations and `-l` disables inlining, which helps preserve function boundaries and symbols.

## Architecture

### Core Components

1. **Binary Format Detection**: Automatically detects ELF, PE, or Mach-O formats
2. **Symbol Extraction**: Extracts function symbols, variables, and string literals
3. **Function Analysis**: Identifies user-defined functions vs runtime functions
4. **Code Generation**: Reconstructs Go source code from analyzed symbols

### Key Features

- **Smart Symbol Filtering**: Distinguishes between user code and runtime/standard library code
- **Function Inference**: Attempts to infer function parameters and return types based on naming patterns
- **String Recovery**: Extracts meaningful string literals while filtering out system strings
- **Package Structure**: Reconstructs proper Go package structure with imports

## Testing

### Run Unit Tests
```bash
go test ./decompiler -v
```

### Run Integration Tests
```bash
go test -v integration_test.go
```

### Build Test Samples
```bash
cd samples
go build -gcflags="-N -l" -o hello_no_opt hello.go
go build -gcflags="-N -l" -o functions_no_opt functions.go
go build -gcflags="-N -l" -o complex_no_opt complex.go
```

## Sample Programs

The repository includes several sample programs for testing:

- **hello.go**: Simple "Hello, World!" program
- **functions.go**: Program with multiple user-defined functions
- **complex.go**: Program with loops, recursion, and more complex logic

## Accuracy and Limitations

### What the Decompiler Can Do

- ✅ Detect user-defined functions in the main package
- ✅ Extract string literals used in the program
- ✅ Reconstruct basic program structure
- ✅ Generate compilable Go code structure
- ✅ Handle multiple binary formats (ELF, PE, Mach-O)
- ✅ Filter out runtime and standard library noise

### Current Limitations

- ⚠️ Function bodies are reconstructed based on heuristics, not actual bytecode analysis
- ⚠️ Complex data structures and algorithms are simplified
- ⚠️ Optimized binaries (with inlining) may lose function boundaries
- ⚠️ Generic types and advanced Go features may not be perfectly reconstructed

### Accuracy Considerations

The decompiler aims for structural accuracy rather than line-by-line code recreation. It focuses on:

1. **Function signatures**: Names, parameters (inferred), return types (inferred)
2. **Program flow**: Main function and user-defined function calls
3. **String literals**: Actual strings used in the program
4. **Package structure**: Correct Go package and import declarations

## Example Output

Input program (functions.go):
```go
package main

import "fmt"

func add(a, b int) int {
    return a + b
}

func greet(name string) string {
    return "Hello, " + name
}

func main() {
    result := add(5, 3)
    fmt.Printf("5 + 3 = %d\n", result)
    
    greeting := greet("Go Decompiler")
    fmt.Println(greeting)
}
```

Decompiled output:
```go
// Decompiled Go source code
// Generated by Go Decompiler v1.0

package main

import (
    "fmt"
)

func add() {
    // Decompiled function: main.add
    // Mathematical operation detected
    result := 0 // Placeholder calculation
    return result
}

func greet() {
    // Decompiled function: main.greet
    // Generic function implementation
    // Original logic reconstructed from binary analysis
}

func main() {
    // Reconstructed from string literals found in binary
    fmt.Println("5 + 3 = %d")
    fmt.Println("Hello, ")
}
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Ensure all tests pass
5. Submit a pull request

## License

This project is open source. See the repository for license details.

## Disclaimer

This decompiler is for educational and research purposes. The accuracy of decompilation depends on the complexity of the original program and compilation settings. Always respect software licenses and intellectual property rights when using decompilation tools.